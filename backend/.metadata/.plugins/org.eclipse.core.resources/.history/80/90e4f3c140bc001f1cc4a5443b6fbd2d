package com.example.userservice.repository;

import static org.assertj.core.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.test.context.ActiveProfiles;

import com.example.userservice.entity.User;

@DataJpaTest(excludeAutoConfiguration = FlywayAutoConfiguration.class) // Flywayの自動構成を除外
@AutoConfigureTestDatabase(replace = Replace.ANY) // H2データベースを強制的に使用
@ActiveProfiles("test")
public class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    // 正常系テスト

    @Test
    void existsByUsername_ReturnTrue_WhenExists() {
        User user = User.builder()
                .username("testuser")
                .email("testuser@test.com")
                .password("password")
                .build();
        userRepository.save(user);

        boolean exists = userRepository.existsByUsername("testuser");
        assertThat(exists).isTrue();
    }

    @Test
    void existsByUsername_ReturnFalse_WhenNotExists() {
        boolean exists = userRepository.existsByUsername("nonexistent");
        assertThat(exists).isFalse();
    }

    @Test
    void findByUsername_Success() {
        User user = User.builder()
                .username("finduser")
                .email("finduser@test.com")
                .password("password")
                .build();
        userRepository.save(user);

        User found = userRepository.findByUsername("finduser").orElse(null);
        assertThat(found).isNotNull();
        assertThat(found.getEmail()).isEqualTo("finduser@test.com");
    }

    @Test
    void findByUsername_ReturnEmpty_WhenUserNotFound() {
        User found = userRepository.findByUsername("unknown").orElse(null);
        assertThat(found).isNull();
    }

    @Test
    void saveUser_Success() {
        User user = User.builder()
                .username("saveuser")
                .email("saveuser@test.com")
                .password("password")
                .build();
        User saved = userRepository.save(user);
        assertThat(saved.getId()).isNotNull();
    }

    @Test
    void deleteUser_Success() {
        User user = User.builder()
                .username("deleteuser")
                .email("deleteuser@test.com")
                .password("password")
                .build();
        User saved = userRepository.save(user);
        userRepository.delete(saved);

        boolean exists = userRepository.existsById(saved.getId());
        assertThat(exists).isFalse();
    }

    // 異常系テスト

    @Test
    void saveUser_DuplicateUsername_ShouldThrowException() {
        // 既存のユーザーを保存
        User user1 = User.builder()
                .username("duplicateUser")
                .email("user1@example.com")
                .password("password123")
                .build();
        userRepository.saveAndFlush(user1);

        // 重複したユーザー名を持つ新しいユーザーを作成
        User user2 = User.builder()
                .username("duplicateUser") // 重複したユーザー名
                .email("user2@example.com")
                .password("password456")
                .build();

        // テスト実行と検証
        assertThatThrownBy(() -> userRepository.saveAndFlush(user2))
                .isInstanceOf(DataIntegrityViolationException.class)
                .hasMessageContaining("constraint [users.username]");
    }

    @Test
    void saveUser_DuplicateEmail_ShouldThrowException() {
        // 既存のユーザーを保存
        User user1 = User.builder()
                .username("user1")
                .email("duplicate@example.com")
                .password("password123")
                .build();
        userRepository.saveAndFlush(user1);

        // 重複したメールアドレスを持つ新しいユーザーを作成
        User user2 = User.builder()
                .username("user2")
                .email("duplicate@example.com") // 重複したメールアドレス
                .password("password456")
                .build();

        // テスト実行と検証
        assertThatThrownBy(() -> userRepository.saveAndFlush(user2))
                .isInstanceOf(DataIntegrityViolationException.class)
                .hasMessageContaining("constraint [users.email]");
    }

    @Test
    void saveUser_NullUsername_ShouldThrowException() {
        // ユーザー名がnullのユーザーを作成
        User user = User.builder()
                .username(null) // null
                .email("nullusername@example.com")
                .password("password123")
                .build();

        // テスト実行と検証
        assertThatThrownBy(() -> userRepository.saveAndFlush(user))
                .isInstanceOf(DataIntegrityViolationException.class)
                .hasMessageContaining("not-null property references a null or transient value");
    }

    @Test
    void deleteUser_NonExistentUser_ShouldThrowException() {
        // 存在しないユーザーIDで削除を試みる
        Long nonExistentUserId = 999L;

        // テスト実行と検証
        assertThatThrownBy(() -> userRepository.deleteById(nonExistentUserId))
                .isInstanceOf(EmptyResultDataAccessException.class)
                .hasMessageContaining("No class com.example.userservice.entity.User entity with id " + nonExistentUserId + " exists!");
    }

    // データベース接続エラーのテストは別途統合テストで行うことを推奨
}
